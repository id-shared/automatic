#include <windows.h>
#include <iostream>

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
  switch (uMsg) {
  case WM_INPUT: {
    UINT dwSize;
    GetRawInputData((HRAWINPUT)lParam, RID_INPUT, nullptr, &dwSize, sizeof(RAWINPUTHEADER));
    LPBYTE lpb = new BYTE[dwSize];
    if (lpb == nullptr) return 0;

    if (GetRawInputData((HRAWINPUT)lParam, RID_INPUT, lpb, &dwSize, sizeof(RAWINPUTHEADER)) != dwSize) {
      std::cerr << "Error getting raw input data." << std::endl;
    }

    RAWINPUT* rawInput = (RAWINPUT*)lpb;
    if (rawInput->header.dwType == RIM_TYPEMOUSE) {
      // Process mouse movement data
      int mouseX = rawInput->data.mouse.lLastX;
      int mouseY = rawInput->data.mouse.lLastY;
      std::cout << "Mouse moved: X=" << mouseX << ", Y=" << mouseY << std::endl;
    }

    delete[] lpb;
    return 0;
  }
  case WM_DESTROY:
    PostQuitMessage(0);
    return 0;
  }

  return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

int main() {
  // Register the window class
  const wchar_t CLASS_NAME[] = L"RawInputWindowClass"; // Use wide-character literal
  WNDCLASS wc = {};
  wc.lpfnWndProc = WindowProc;
  wc.hInstance = GetModuleHandle(nullptr);
  wc.lpszClassName = CLASS_NAME;

  RegisterClass(&wc);

  // Create the window
  HWND hwnd = CreateWindowEx(
    0, CLASS_NAME, L"HID Mouse Movement Detector", WS_OVERLAPPEDWINDOW, // Use wide-character literal
    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
    nullptr, nullptr, GetModuleHandle(nullptr), nullptr
  );

  // Register for raw input
  RAWINPUTDEVICE rid;
  rid.usUsagePage = 0x01;  // Generic desktop controls
  rid.usUsage = 0x02;       // Mouse
  rid.dwFlags = RIDEV_INPUTSINK; // Receive input even when not in the foreground
  rid.hwndTarget = hwnd;

  if (RegisterRawInputDevices(&rid, 1, sizeof(rid)) == -1) {
    std::cerr << "Failed to register raw input devices." << std::endl;
    return 1;
  }

  ShowWindow(hwnd, SW_HIDE); // Hide the window

  // Message loop
  MSG msg;
  while (GetMessage(&msg, nullptr, 0, 0)) {
    TranslateMessage(&msg);
    DispatchMessage(&msg);
  }

  return 0;
}

#include <windows.h>
#include <setupapi.h>
#include <hidsdi.h>
#include <iostream>
#include <string>

#pragma comment(lib, "setupapi.lib")
#pragma comment(lib, "hid.lib")

void ProcessMouseData(BYTE* data, int length) {
  if (length >= 3) {
    int mouseX = (int)(signed char)data[1]; // X movement
    int mouseY = (int)(signed char)data[2]; // Y movement
    std::cout << "Mouse moved: X=" << mouseX << ", Y=" << mouseY << std::endl;
  }
}

void ReadFromDevice(HANDLE hDevice) {
  // Initialize a buffer for HID input reports
  BYTE buffer[64]; // Adjust the size based on your mouse's report descriptor
  memset(buffer, 0, sizeof(buffer)); // Clear buffer

  while (true) {
    // If your device requires a report ID, set it here (e.g., buffer[0] = 1;)
    // buffer[0] = 1; // Uncomment if your device uses report ID 1

    // Try reading the input report
    if (HidD_GetInputReport(hDevice, buffer, sizeof(buffer))) {
      ProcessMouseData(buffer, sizeof(buffer)); // Process the data read
    }
    else {
      std::cerr << "Failed to read input report. Error Code: " << GetLastError() << std::endl;
    }

    Sleep(10); // Adjust polling interval as necessary
  }
}

bool IsMatchingDevice(const std::wstring& deviceId) {
  // Check if the device ID matches the target VID and PID
  return deviceId.find(L"HID\\VID_046D&PID_C547") == 0; // Adjust this for your mouse's VID & PID
}

int main() {
  GUID InterfaceGuid;
  HidD_GetHidGuid(&InterfaceGuid);

  HDEVINFO hDevInfo = SetupDiGetClassDevs(&InterfaceGuid, nullptr, nullptr, DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
  if (hDevInfo == INVALID_HANDLE_VALUE) {
    std::cerr << "Failed to get device information set. Error Code: " << GetLastError() << std::endl;
    return 1;
  }

  SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
  DeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

  for (DWORD i = 0; SetupDiEnumDeviceInterfaces(hDevInfo, nullptr, &InterfaceGuid, i, &DeviceInterfaceData); i++) {
    DWORD requiredSize;
    SetupDiGetDeviceInterfaceDetail(hDevInfo, &DeviceInterfaceData, nullptr, 0, &requiredSize, nullptr);
    PSP_DEVICE_INTERFACE_DETAIL_DATA pInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)malloc(requiredSize);
    pInterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

    if (!SetupDiGetDeviceInterfaceDetail(hDevInfo, &DeviceInterfaceData, pInterfaceDetailData, requiredSize, nullptr, nullptr)) {
      std::cerr << "Failed to get device interface detail. Error Code: " << GetLastError() << std::endl;
      free(pInterfaceDetailData);
      continue;
    }

    // Retrieve the device info
    SP_DEVINFO_DATA DeviceInfoData;
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

    WCHAR deviceId[MAX_PATH];
    if (SetupDiEnumDeviceInfo(hDevInfo, i, &DeviceInfoData) &&
      SetupDiGetDeviceInstanceId(hDevInfo, &DeviceInfoData, deviceId, sizeof(deviceId) / sizeof(WCHAR), nullptr)) {
      std::wcout << L"Device ID: " << deviceId << std::endl; // Debug output

      // Check if the device matches the target VID
      if (!IsMatchingDevice(deviceId)) {
        free(pInterfaceDetailData);
        continue; // Skip to the next device if it doesn't match
      }
    }

    std::wcout << L"Matching device found: " << pInterfaceDetailData->DevicePath << std::endl;

    HANDLE hDevice = CreateFileW(
      pInterfaceDetailData->DevicePath,
      GENERIC_READ | GENERIC_WRITE,
      FILE_SHARE_READ | FILE_SHARE_WRITE,
      nullptr,
      OPEN_EXISTING,
      0,
      nullptr
    );

    if (hDevice == INVALID_HANDLE_VALUE) {
      DWORD dwError = GetLastError();
      std::cerr << "Failed to open device. Error Code: " << dwError << std::endl;

      // Log additional information based on the error code
      if (dwError == ERROR_ACCESS_DENIED) {
        std::cerr << "Access denied. Try running the program as an administrator." << std::endl;
      }
      else if (dwError == ERROR_FILE_NOT_FOUND) {
        std::cerr << "The specified device was not found." << std::endl;
      }
      else {
        std::cerr << "Error Code Description: " << std::system_category().message(dwError) << std::endl;
      }
      free(pInterfaceDetailData);
      continue; // Skip to the next device
    }

    std::wcout << L"Device opened successfully: " << pInterfaceDetailData->DevicePath << std::endl;

    // Start reading from the device
    ReadFromDevice(hDevice);

    CloseHandle(hDevice);
    free(pInterfaceDetailData);
    break; // Exit after the first successful device for testing
  }

  SetupDiDestroyDeviceInfoList(hDevInfo);

  // Wait for user input to exit
  std::cout << "Press Enter to exit." << std::endl;
  std::cin.get();

  return 0;
}

#include <windows.h>
#include <iostream>
#include <setupapi.h>
#include <hidsdi.h>
#include <initguid.h>
#include <usbiodef.h>
#include <string>

#pragma comment(lib, "hid.lib")
#pragma comment(lib, "setupapi.lib")

void LogHIDPackets(const std::string& deviceInstancePath) {
  // Add prefix for the device instance path
  std::string fullPath = "\\\\?\\hid#" + deviceInstancePath;

  // Open the HID device
  HANDLE deviceHandle = CreateFileA(
    fullPath.c_str(),
    GENERIC_READ | GENERIC_WRITE,
    FILE_SHARE_READ | FILE_SHARE_WRITE,
    nullptr,
    OPEN_EXISTING,
    0,
    nullptr
  );

  if (deviceHandle == INVALID_HANDLE_VALUE) {
    std::cerr << "Failed to open device. Error: " << GetLastError() << std::endl;
    return;
  }

  // Prepare to read input reports
  HIDD_ATTRIBUTES attributes;
  unsigned char inputBuffer[64]; // Buffer for input reports
  DWORD bytesRead;

  // Get the device attributes
  if (HidD_GetAttributes(deviceHandle, &attributes)) {
    std::cout << "Vendor ID: " << std::hex << attributes.VendorID << std::endl;
    std::cout << "Product ID: " << std::hex << attributes.ProductID << std::endl;

    while (true) {
      // Read input reports
      if (ReadFile(deviceHandle, inputBuffer, sizeof(inputBuffer), &bytesRead, nullptr)) {
        std::cout << "Input Report: ";
        for (size_t i = 0; i < bytesRead; ++i) {
          std::cout << std::hex << static_cast<int>(inputBuffer[i]) << " ";
        }
        std::cout << std::dec << std::endl;
      }
      else {
        std::cerr << "Failed to read from device. Error: " << GetLastError() << std::endl;
        break;
      }

      // Small delay to avoid busy-waiting
      Sleep(10);
    }
  }
  else {
    std::cerr << "Failed to get attributes. Error: " << GetLastError() << std::endl;
  }

  // Close the device handle
  CloseHandle(deviceHandle);
}

int main() {
  // Example device instance path
  LogHIDPackets("vid_046d&pid_c547&mi_00#7&343734ca&0&0000");

  std::string deviceInstancePath;
  std::cout << "Enter device instance path: ";
  std::getline(std::cin, deviceInstancePath);

  return 0;
}
